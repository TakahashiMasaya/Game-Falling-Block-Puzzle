@startuml Overview

namespace Presenters {
  namespace Dom {
    class Dom {
      - mainController: Dom
      - spinLeft: Dom
      - spinRight: Dom
      - enter: Dom

      + init({ mainController: Dom, spinLeft: Dom, spinRight: Dom, enter: Dom }): void
      + opening(): void
      + playing(): void
      + gameover(): void
    }
    Dom <--- InteractorForPresenter.InteractiveScreen
  }
  namespace Screen {
    class Canvas {
      - images: {'player': { src:'images/shooting_player.png', rate:1.00, obj:new Image}}
      - init(): void
      + drawImage({ texture: string, sx, number, sy, number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number }): void
    }
    Canvas <--- InteractorForPresenter.InteractiveScreen
  }
  namespace Audio {
    class AudioContext{
      - playing: []
      - sound: []
      - context: AudioContext
      - data: { 'shot_laser': { src:'audios/shot_laser.mp3', volume:1.0, loopOffset: 0, buf:{}},
      + init() : void
      + play({ name: string }) : void
      + stop({ name: string }): void
      + stop(): void
      + makeSound({ name: string }) : void
    }
    AudioContext <--- InteractorForPresenter.InteractiveScreen
  }
}

' Presentersに情報を渡すための情報を加工する
namespace InteractorForPresenter {
  class InteractiveScreen {
    + draw({{ x: number, y: number, textue: string }[]): void
    + sound(): void
    + DOMOpening(): void
    + DOMPlaying(): void
    + DOMGameover(): void
  }
}

namespace InteractorForController {
  class InteractiveController {
    - status: { up: boolean, right: boolean, down: boolean, left: boolean, spinRight: boolean, spinLeft: boolean, enter: boolean }
    + up(): void
    + right(): void
    + down(): void
    + left(): void
    + spinLeft(): void
    + spinRight(): void
    + enter(): void
    + offUp(): void
    + offRight(): void
    + offDown(): void
    + offLeft(): void
    + offSpinLeft(): void
    + offSpinRight(): void
    + offEnter(): void
    + keyStatus(): { up: boolean, right: boolean, down: boolean, left: boolean, spinRight: boolean, spinLeft: boolean, enter: boolean }
  }
}

namespace Application {
  namespace Scene {
    class SceneChanger{
      - scene: SceneStart | ScenePlaying | SceneGameover | null
      + next(): void
    }
    interface SceneInterface {
      + start(): void
      + move(): void
      + pause(): void
      + next(): void
    }

    SceneChanger --> SceneInterface
    SceneInterface <|-- SceneStart
    SceneInterface <|-- ScenePlaying
    SceneInterface <|-- SceneGameover
    class SceneStart{
    }
    class ScenePlaying{
      - tetrominoCollidedTimes: number
      - soundForBackground: string
      - soundForReachedTetromino: string
      - status: 'ready'|'playing'

    }
    InteractorForPresenter.InteractiveScreen <--- SceneInterface
    InteractorForController.InteractiveController <--- SceneInterface
  }

  ' tetrominoとfieldで衝突判定をする
  class CollisionalTetromino {
    + isCollision({ tetromino: Piece, field: Field }): boolean
    + isTetrominoReached({ tetromino: Piece, field: Field }): boolean
  }

  ' fieldを描画用に置換する
  class TranferringToDraw {
    + set(string[][]): void
    + transfer(): { x: number, y: number, texture: string }[] 
  }

  ' 次のtetrominoをセットする
  Class NextTetrominos {
    - list: number[]
    - stockQuantity: number
    - tetrominoQuantity: number
    - readyToTetrominos(): void
    + getList(): number[]
    + next(): number
  }

  NextTetrominos <-- Application.Scene.ScenePlaying
  TranferringToDraw <-- Application.Scene.ScenePlaying
  TranferringToDraw <-- Application.Scene.SceneGameover
  CollisionalTetromino <-- Application.Scene.ScenePlaying

}

namespace Controllers {
  interface Controller {
    + createEvent(): void
  }
  class PC {
    + createEvent(): void
  }
  class SP {
    - mainController: Dom
    - spinLeft: Dom
    - spinRight: Dom
    - enter: Dom
    + createEvent(): void
  }
  Controller <|-- PC
  Controller <|-- SP
  InteractorForController.InteractiveController <--- Controller
}

namespace Domain {
  nameSpace Design {
    class ScoreBoard {
      - x: number
      - y: number
      - score: Score
      - texture: 'scoreBoard'
      + getStatus(): { x: number, y: number, texture: string }
    }
    interface GameBoardInterface {
      - x: number
      - y: number
      - gameBoard: GameBoard
      - texture: 'gameBoard'
      + getStatus(): { x: number, y: number, texture: string }
    }
    GameBoardInterface <|-- GameBoard10x20
    class GameBoard10x20 {
      - texture: 'gameBoard10x20'
    }
    class NextTetrominosBoard {
      - x: number
      - y: number
      - nextTetrominos: NextTetrominos 
      - texture: 'nextTetrominosBoard'
      + getStatus(): { x: number, y: number, texture: string }
    }
  }
  Application.Scene.ScenePlaying ---> Domain.Design
  Application.Scene.SceneGameover ---> Domain.Design

  namespace Parts {
    interface ScoreInterface {
      - score: number
      + add(number: number): void
      + reset(): void
    }
    class Score {}
    ScoreInterface <|-- Score

    interface FieldInterface {
      + update({ x: number, y: number, tetromino: string[][] }): void
      + canRemoveFullRow(): boolean
      + removeFullRow(): void
      + getStatus(): string[][]
    }
    FieldInterface <|-- Field10x20
    class Field10x20 {
      - status: [ ['0', '0', ... '0'], ['0', '0', ... '0'], ... ['0', '0', ... '0']]
      - replaceBitString({ string: string, replace: string, start: number })
    }

    Class ActiveTetromino {
      - tetromino: Piece

      + start({ x: number, y: number, tetromino: number }): void
      + nextAction({left: boolean, right: boolean, down: boolean, spinLeft: boolean, spinRight: booelan }): { x: number: y: number, tetromino: string[][]}
      + setAction({left: boolean, right: boolean, down: boolean, spinLeft: boolean, spinRight: booelan }): void
      + getStatus(): { x: number, y: number, tetromino: string[][] }
    }
    Interface InterfaceTetromino {
      - pieces: string[][]
      - spinStatus: number

      + spinLeft(): void
      + spinRight(): void
      + getPiece(): string[][]
      + getPieceToSpinLeft(): string[][]
      + getPieceToSpinRight(): string[][]
    }

    class Tetromino {
      - pieces: [][]
    }

    class ITetromino {
      - pieces: [['0', 'l', '0', '0'], ['0', 'l', '0', '0'], ['0', 'l', '0', '0'], ['0', 'l', '0', '0']]
    }
    class LTetromino {
      - pieces: [[l', '0', '0',], ['l', '0', '0'], ['l', 'l', '0']]
    }
    class OTetromino {
      - pieces: [['o', 'o'], ['o', 'o']]
    }
    class STetromino {
      - pieces: [['0', 's', 's'], ['s', 's', '0'], ['0', '0', '0']]
    }
    class ZTetromino {
      - pieces: [['z', 'z', '0'], ['0', 'z', 'z'], ['0', '0', '0']]
    }
    class JTetromino {
      - pieces: [['0', '0', 'j'], ['0', '0', 'j'], ['0', 'j', 'j']]
    }
    class Piece {
      - pieces: [['0', 't', '0'], ['t', 't', 't'], ['0', '0', '0']]
    }

    ActiveTetromino ---> Tetromino
    InterfaceTetromino <|-- Tetromino 
    Tetromino <|-- ITetromino
    Tetromino <|-- LTetromino
    Tetromino <|-- OTetromino
    Tetromino <|-- STetromino
    Tetromino <|-- ZTetromino
    Tetromino <|-- JTetromino
    Tetromino <|-- Piece
  }

  Application.Scene.ScenePlaying ---> Domain.Parts.ActiveTetromino
  Application.Scene.ScenePlaying ---> Domain.Parts.FieldInterface
  Application.Scene.ScenePlaying ---> Domain.Parts.ScoreInterface
}

@enduml